;; x64 ISLE lowering rules
;; Minimal bootstrap set for instruction selection

;; Integer arithmetic lowering

;; iadd: Add two integers
(rule (lower (iadd ty x y))
      (x64_add_rr ty x y))

;; isub: Subtract integers
(rule (lower (isub ty x y))
      (x64_sub_rr ty x y))

;; imul: Multiply integers
(rule (lower (imul ty x y))
      (x64_imul_rr ty x y))

;; Immediate forms

;; iadd with small immediate
(rule (lower (iadd ty x (iconst k)))
      (if-let $true (simm32 k))
      (x64_add_imm ty x k))

;; isub with small immediate
(rule (lower (isub ty x (iconst k)))
      (if-let $true (simm32 k))
      (x64_sub_imm ty x k))

;; Load/store lowering

;; load: Load from memory
(rule (lower (load ty addr _flags _offset))
      (x64_load ty addr))

;; store: Store to memory
(rule (lower (store val addr _flags _offset))
      (x64_store val addr))

;; Control flow lowering

;; jump: Unconditional branch
(rule (lower (jump target))
      (x64_jmp target))

;; brif: Conditional branch
(rule (lower (brif cond target))
      (x64_brif cond target))

;; return: Return from function
(rule (lower (return))
      (x64_ret))

;; Constant materialization

;; iconst: Integer constant
(rule (lower (iconst ty k))
      (x64_iconst ty k))

;; Bitwise operations

;; band: Bitwise AND
(rule (lower (band ty x y))
      (x64_and_rr ty x y))

;; bor: Bitwise OR
(rule (lower (bor ty x y))
      (x64_or_rr ty x y))

;; bxor: Bitwise XOR
(rule (lower (bxor ty x y))
      (x64_xor_rr ty x y))

;; Comparison operations

;; icmp: Integer comparison
(rule (lower (icmp cc ty x y))
      (x64_icmp cc ty x y))

;; Shift operations

;; ishl: Shift left
(rule (lower (ishl ty x y))
      (x64_shl ty x y))

;; ushr: Unsigned shift right
(rule (lower (ushr ty x y))
      (x64_shr ty x y))

;; sshr: Signed shift right (arithmetic)
(rule (lower (sshr ty x y))
      (x64_sar ty x y))

;; Shift with immediate
(rule (lower (ishl ty x (iconst k)))
      (if-let $true (simm32 k))
      (x64_shl_imm ty x k))

(rule (lower (ushr ty x (iconst k)))
      (if-let $true (simm32 k))
      (x64_shr_imm ty x k))

(rule (lower (sshr ty x (iconst k)))
      (if-let $true (simm32 k))
      (x64_sar_imm ty x k))

;; Negation and complement

;; ineg: Negate integer
(rule (lower (ineg ty x))
      (x64_neg ty x))

;; bnot: Bitwise NOT
(rule (lower (bnot ty x))
      (x64_not ty x))

;; Helper extractors

;; Check if value fits in signed 32-bit
(extractor (simm32 val)
  (if (<= -2147483648 val 2147483647)
      val))

;; Constructor terms for x64 instructions

(type X64Inst (enum))

;; Arithmetic
(decl x64_add_rr (Type Value Value) X64Inst)
(decl x64_add_imm (Type Value i64) X64Inst)
(decl x64_sub_rr (Type Value Value) X64Inst)
(decl x64_sub_imm (Type Value i64) X64Inst)
(decl x64_imul_rr (Type Value Value) X64Inst)
(decl x64_neg (Type Value) X64Inst)

;; Bitwise
(decl x64_and_rr (Type Value Value) X64Inst)
(decl x64_or_rr (Type Value Value) X64Inst)
(decl x64_xor_rr (Type Value Value) X64Inst)
(decl x64_not (Type Value) X64Inst)

;; Comparison
(decl x64_icmp (IntCC Type Value Value) X64Inst)

;; Shifts
(decl x64_shl (Type Value Value) X64Inst)
(decl x64_shr (Type Value Value) X64Inst)
(decl x64_sar (Type Value Value) X64Inst)
(decl x64_shl_imm (Type Value i64) X64Inst)
(decl x64_shr_imm (Type Value i64) X64Inst)
(decl x64_sar_imm (Type Value i64) X64Inst)

;; Memory
(decl x64_load (Type Value) X64Inst)
(decl x64_store (Value Value) X64Inst)

;; Control flow
(decl x64_jmp (Block) X64Inst)
(decl x64_brif (Value Block) X64Inst)
(decl x64_ret () X64Inst)

;; Constants
(decl x64_iconst (Type i64) X64Inst)
(decl x64_fconst (Type f64) X64Inst)

;; Floating-point arithmetic

;; fadd: FP addition
(rule (lower (fadd ty x y))
      (x64_fadd ty x y))

;; fsub: FP subtraction
(rule (lower (fsub ty x y))
      (x64_fsub ty x y))

;; fmul: FP multiplication
(rule (lower (fmul ty x y))
      (x64_fmul ty x y))

;; fdiv: FP division
(rule (lower (fdiv ty x y))
      (x64_fdiv ty x y))

;; fsqrt: FP square root
(rule (lower (fsqrt ty x))
      (x64_fsqrt ty x))

;; fmin/fmax: FP min/max
(rule (lower (fmin ty x y))
      (x64_fmin ty x y))

(rule (lower (fmax ty x y))
      (x64_fmax ty x y))

;; FP conversions

;; fcvt_from_sint: Convert signed int to FP
(rule (lower (fcvt_from_sint ty x))
      (x64_cvtsi2s ty x))

;; fcvt_from_uint: Convert unsigned int to FP
(rule (lower (fcvt_from_uint ty x))
      (x64_cvtui2s ty x))

;; fcvt_to_sint: Convert FP to signed int (with saturation)
(rule (lower (fcvt_to_sint ty x))
      (x64_cvts2si ty x))

;; fcvt_to_uint: Convert FP to unsigned int (with saturation)
(rule (lower (fcvt_to_uint ty x))
      (x64_cvts2ui ty x))

;; fcvt_low_from_sint: Convert low lane signed int to FP
(rule (lower (fcvt_low_from_sint ty x))
      (x64_cvtsi2s_low ty x))

;; fdemote: F64 to F32
(rule (lower (fdemote x))
      (x64_cvtsd2ss x))

;; fpromote: F32 to F64
(rule (lower (fpromote x))
      (x64_cvtss2sd x))

;; FP comparison
(rule (lower (fcmp cc ty x y))
      (x64_fcmp cc ty x y))

;; SIMD operations

;; vconst: Vector constant
(rule (lower (vconst ty bits))
      (x64_vconst ty bits))

;; vsplat: Broadcast scalar to vector lanes
(rule (lower (vsplat ty x))
      (x64_vsplat ty x))

;; vselect: Lane-wise select
(rule (lower (vselect mask tval fval))
      (x64_vselect mask tval fval))

;; vadd: Vector addition
(rule (lower (vadd ty x y))
      (x64_vadd ty x y))

;; vsub: Vector subtraction
(rule (lower (vsub ty x y))
      (x64_vsub ty x y))

;; vmul: Vector multiplication
(rule (lower (vmul ty x y))
      (x64_vmul ty x y))

;; vand/vor/vxor: Vector bitwise
(rule (lower (vand ty x y))
      (x64_vand ty x y))

(rule (lower (vor ty x y))
      (x64_vor ty x y))

(rule (lower (vxor ty x y))
      (x64_vxor ty x y))

;; vnot: Vector bitwise NOT
(rule (lower (vnot ty x))
      (x64_vnot ty x))

;; vshl/vushr/vsshr: Vector shifts
(rule (lower (vshl ty x y))
      (x64_vshl ty x y))

(rule (lower (vushr ty x y))
      (x64_vushr ty x y))

(rule (lower (vsshr ty x y))
      (x64_vsshr ty x y))

;; vshl_imm: Vector shift with immediate
(rule (lower (vshl ty x (iconst k)))
      (if-let $true (simm8 k))
      (x64_vshl_imm ty x k))

(rule (lower (vushr ty x (iconst k)))
      (if-let $true (simm8 k))
      (x64_vushr_imm ty x k))

(rule (lower (vsshr ty x (iconst k)))
      (if-let $true (simm8 k))
      (x64_vsshr_imm ty x k))

;; vcmp: Vector comparison
(rule (lower (vcmp cc ty x y))
      (x64_vcmp cc ty x y))

;; vmin/vmax: Vector min/max
(rule (lower (vmin ty x y))
      (x64_vmin ty x y))

(rule (lower (vmax ty x y))
      (x64_vmax ty x y))

;; shuffle: Vector shuffle
(rule (lower (shuffle ty x y mask))
      (x64_shuffle ty x y mask))

;; swizzle: Dynamic lane selection
(rule (lower (swizzle ty x idx))
      (x64_swizzle ty x idx))

;; extractlane: Extract scalar from vector
(rule (lower (extractlane ty x idx))
      (x64_extractlane ty x idx))

;; insertlane: Insert scalar into vector
(rule (lower (insertlane ty x val idx))
      (x64_insertlane ty x val idx))

;; Additional extractors

;; Check if value fits in signed 8-bit
(extractor (simm8 val)
  (if (<= -128 val 127)
      val))

;; FP/SIMD constructor terms

;; FP arithmetic
(decl x64_fadd (Type Value Value) X64Inst)
(decl x64_fsub (Type Value Value) X64Inst)
(decl x64_fmul (Type Value Value) X64Inst)
(decl x64_fdiv (Type Value Value) X64Inst)
(decl x64_fsqrt (Type Value) X64Inst)
(decl x64_fmin (Type Value Value) X64Inst)
(decl x64_fmax (Type Value Value) X64Inst)

;; FP conversions
(decl x64_cvtsi2s (Type Value) X64Inst)
(decl x64_cvtui2s (Type Value) X64Inst)
(decl x64_cvts2si (Type Value) X64Inst)
(decl x64_cvts2ui (Type Value) X64Inst)
(decl x64_cvtsi2s_low (Type Value) X64Inst)
(decl x64_cvtsd2ss (Value) X64Inst)
(decl x64_cvtss2sd (Value) X64Inst)

;; FP comparison
(decl x64_fcmp (FloatCC Type Value Value) X64Inst)

;; SIMD
(decl x64_vconst (Type u128) X64Inst)
(decl x64_vsplat (Type Value) X64Inst)
(decl x64_vselect (Value Value Value) X64Inst)
(decl x64_vadd (Type Value Value) X64Inst)
(decl x64_vsub (Type Value Value) X64Inst)
(decl x64_vmul (Type Value Value) X64Inst)
(decl x64_vand (Type Value Value) X64Inst)
(decl x64_vor (Type Value Value) X64Inst)
(decl x64_vxor (Type Value Value) X64Inst)
(decl x64_vnot (Type Value) X64Inst)
(decl x64_vshl (Type Value Value) X64Inst)
(decl x64_vushr (Type Value Value) X64Inst)
(decl x64_vsshr (Type Value Value) X64Inst)
(decl x64_vshl_imm (Type Value i64) X64Inst)
(decl x64_vushr_imm (Type Value i64) X64Inst)
(decl x64_vsshr_imm (Type Value i64) X64Inst)
(decl x64_vcmp (IntCC Type Value Value) X64Inst)
(decl x64_vmin (Type Value Value) X64Inst)
(decl x64_vmax (Type Value Value) X64Inst)
(decl x64_shuffle (Type Value Value u128) X64Inst)
(decl x64_swizzle (Type Value Value) X64Inst)
(decl x64_extractlane (Type Value u32) X64Inst)
(decl x64_insertlane (Type Value Value u32) X64Inst)
