;; aarch64 ISLE lowering rules
;; Minimal bootstrap set for ARM64 instruction selection

;; Integer arithmetic lowering

;; iadd: Add two integers
(rule (lower (iadd ty x y))
      (aarch64_add_rr ty x y))

;; isub: Subtract integers
(rule (lower (isub ty x y))
      (aarch64_sub_rr ty x y))

;; imul: Multiply integers
(rule (lower (imul ty x y))
      (aarch64_mul_rr ty x y))

;; smul_hi: Signed multiply returning upper bits (64×64→128, return high 64)
(rule (lower (smul_hi ty x y))
      (if-let $I64 ty)
      (aarch64_smulh x y))

;; umul_hi: Unsigned multiply returning upper bits (64×64→128, return high 64)
(rule (lower (umul_hi ty x y))
      (if-let $I64 ty)
      (aarch64_umulh x y))

;; sdiv: Signed divide
(rule (lower (sdiv ty x y))
      (aarch64_sdiv ty x y))

;; udiv: Unsigned divide
(rule (lower (udiv ty x y))
      (aarch64_udiv ty x y))

;; srem: Signed remainder (implemented as sdiv + msub)
;; srem(x, y) = x - (x / y) * y
(rule (lower (srem ty x y))
      (let ((quot Aarch64Inst (aarch64_sdiv ty x y)))
            (aarch64_msub ty quot y x)))

;; urem: Unsigned remainder (implemented as udiv + msub)
;; urem(x, y) = x - (x / y) * y
(rule (lower (urem ty x y))
      (let ((quot Aarch64Inst (aarch64_udiv ty x y)))
            (aarch64_msub ty quot y x)))

;; Shift operations lowering

;; ishl: Integer shift left (register form)
(rule (lower (ishl ty x y))
      (aarch64_lsl_rr ty x y))

;; ishl: Integer shift left (immediate form)
(rule (lower (ishl ty x (iconst k)))
      (if-let amt (valid_shift_imm k))
      (aarch64_lsl_imm ty x amt))

;; ushr: Unsigned shift right (register form)
(rule (lower (ushr ty x y))
      (aarch64_lsr_rr ty x y))

;; ushr: Unsigned shift right (immediate form)
(rule (lower (ushr ty x (iconst k)))
      (if-let amt (valid_shift_imm k))
      (aarch64_lsr_imm ty x amt))

;; sshr: Signed shift right (register form)
(rule (lower (sshr ty x y))
      (aarch64_asr_rr ty x y))

;; sshr: Signed shift right (immediate form)
(rule (lower (sshr ty x (iconst k)))
      (if-let amt (valid_shift_imm k))
      (aarch64_asr_imm ty x amt))

;; rotr: Rotate right (register form)
(rule (lower (rotr ty x y))
      (aarch64_ror_rr ty x y))

;; rotr: Rotate right (immediate form)
(rule (lower (rotr ty x (iconst k)))
      (if-let amt (valid_shift_imm k))
      (aarch64_ror_imm ty x amt))

;; rotl: Rotate left - NOT IMPLEMENTED YET
;; Note: Needs register negation for variable amount
;; rotl(x, k) = rotr(x, width - k)

;; Bitwise operations lowering

;; band: Bitwise AND (register form)
(rule (lower (band ty x y))
      (aarch64_and_rr ty x y))

;; bor: Bitwise OR (register form)
(rule (lower (bor ty x y))
      (aarch64_orr_rr ty x y))

;; bxor: Bitwise XOR (register form)
(rule (lower (bxor ty x y))
      (aarch64_eor_rr ty x y))

;; bnot: Bitwise NOT (implemented as MVN)
(rule (lower (bnot ty x))
      (aarch64_mvn_rr ty x))

;; Immediate forms

;; iadd with 12-bit immediate
(rule (lower (iadd ty x (iconst k)))
      (if-let $true (uimm12 k))
      (aarch64_add_imm ty x k))

;; isub with 12-bit immediate
(rule (lower (isub ty x (iconst k)))
      (if-let $true (uimm12 k))
      (aarch64_sub_imm ty x k))

;; Load/store lowering

;; load: Load from memory
(rule (lower (load ty addr _flags _offset))
      (aarch64_ldr ty addr))

;; store: Store to memory
(rule (lower (store val addr _flags _offset))
      (aarch64_str val addr))

;; Control flow lowering

;; jump: Unconditional branch
(rule (lower (jump target))
      (aarch64_b target))

;; brif: Conditional branch
(rule (lower (brif cond target))
      (aarch64_b_cond cond target))

;; return: Return from function
(rule (lower (return))
      (aarch64_ret))

;; Constant materialization

;; iconst: Integer constant (16-bit immediate via MOVZ)
(rule (lower (iconst ty k))
      (if-let $true (uimm16 k))
      (aarch64_movz ty k))

;; iconst: Larger constants (needs multiple instructions)
(rule (lower (iconst ty k))
      (aarch64_iconst ty k))

;; Helper extractors

;; Check if value fits in unsigned 12-bit
(extractor (uimm12 val)
  (if (<= 0 val 4095)
      val))

;; Check if value fits in unsigned 16-bit
(extractor (uimm16 val)
  (if (<= 0 val 65535)
      val))

;; Check if value is a valid shift amount (0-63, suitable for both I32 and I64)
(extractor (valid_shift_imm val)
  (if (<= 0 val 63)
      val))

;; Constructor terms for aarch64 instructions

(type Aarch64Inst (enum))

;; Arithmetic
(decl aarch64_add_rr (Type Value Value) Aarch64Inst)
(decl aarch64_add_imm (Type Value i64) Aarch64Inst)
(decl aarch64_sub_rr (Type Value Value) Aarch64Inst)
(decl aarch64_sub_imm (Type Value i64) Aarch64Inst)
(decl aarch64_mul_rr (Type Value Value) Aarch64Inst)
(decl aarch64_smulh (Value Value) Aarch64Inst)
(decl aarch64_umulh (Value Value) Aarch64Inst)
(decl aarch64_sdiv (Type Value Value) Aarch64Inst)
(decl aarch64_udiv (Type Value Value) Aarch64Inst)
(decl aarch64_msub (Type Value Value Value) Aarch64Inst)

;; Shift operations
(decl aarch64_lsl_rr (Type Value Value) Aarch64Inst)
(decl aarch64_lsl_imm (Type Value i64) Aarch64Inst)
(decl aarch64_lsr_rr (Type Value Value) Aarch64Inst)
(decl aarch64_lsr_imm (Type Value i64) Aarch64Inst)
(decl aarch64_asr_rr (Type Value Value) Aarch64Inst)
(decl aarch64_asr_imm (Type Value i64) Aarch64Inst)
(decl aarch64_ror_rr (Type Value Value) Aarch64Inst)
(decl aarch64_ror_imm (Type Value i64) Aarch64Inst)

;; Bitwise operations
(decl aarch64_and_rr (Type Value Value) Aarch64Inst)
(decl aarch64_orr_rr (Type Value Value) Aarch64Inst)
(decl aarch64_eor_rr (Type Value Value) Aarch64Inst)
(decl aarch64_mvn_rr (Type Value) Aarch64Inst)

;; Memory
(decl aarch64_ldr (Type Value) Aarch64Inst)
(decl aarch64_str (Value Value) Aarch64Inst)

;; Control flow
(decl aarch64_b (Block) Aarch64Inst)
(decl aarch64_b_cond (Value Block) Aarch64Inst)
(decl aarch64_ret () Aarch64Inst)

;; Constants
(decl aarch64_movz (Type i64) Aarch64Inst)
(decl aarch64_iconst (Type i64) Aarch64Inst)
