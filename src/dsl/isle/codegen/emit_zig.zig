const std = @import("std");
const testing = std.testing;
const Allocator = std.mem.Allocator;

const sema = @import("../sema.zig");
const trie = @import("../trie.zig");
const match_compiler = @import("match.zig");

/// Options for Zig code generation.
pub const ZigCodegenOptions = struct {
    /// Include debug comments in generated code.
    debug_comments: bool = false,
    /// Prefix for generated function names.
    fn_prefix: []const u8 = "",
};

/// Zig code generator for ISLE rules.
pub const ZigEmitter = struct {
    typeenv: *const sema.TypeEnv,
    termenv: *const sema.TermEnv,
    ruleset: *const trie.RuleSet,
    out: std.ArrayList(u8),
    allocator: Allocator,
    /// Track indentation level.
    indent: usize,

    const Self = @This();

    pub fn init(
        allocator: Allocator,
        typeenv: *const sema.TypeEnv,
        termenv: *const sema.TermEnv,
        ruleset: *const trie.RuleSet,
    ) Self {
        return .{
            .typeenv = typeenv,
            .termenv = termenv,
            .ruleset = ruleset,
            .out = std.ArrayList(u8){},
            .allocator = allocator,
            .indent = 0,
        };
    }

    pub fn deinit(self: *Self) void {
        self.out.deinit(self.allocator);
    }

    /// Generate Zig code from the compiled ruleset.
    pub fn generate(self: *Self, term_id: sema.TermId, options: ZigCodegenOptions) ![]const u8 {
        try self.emitPreamble(options);
        try self.emitContextTrait(options);
        try self.emitTermFunction(term_id, options);
        return self.out.items;
    }

    fn emitPreamble(self: *Self, options: ZigCodegenOptions) !void {
        const writer = self.out.writer(self.allocator);
        try writer.writeAll("// GENERATED BY ISLE. DO NOT EDIT!\n");
        try writer.writeAll("//\n");
        if (options.debug_comments) {
            try writer.writeAll("// Generated from ISLE specification\n");
        }
        try writer.writeAll("\nconst std = @import(\"std\");\n");
        try writer.writeAll("const Allocator = std.mem.Allocator;\n\n");
    }

    fn emitContextTrait(self: *Self, _: ZigCodegenOptions) !void {
        const writer = self.out.writer(self.allocator);
        try writer.writeAll("/// Context for lowering operations.\n");
        try writer.writeAll("/// Implementations must provide all external constructors and extractors.\n");
        try writer.writeAll("pub const Context = struct {\n");
        try writer.writeAll("    allocator: Allocator,\n");
        try writer.writeAll("\n");

        // Emit external function signatures
        for (self.termenv.terms.items) |term| {
            switch (term.kind) {
                .extern_func => {
                    const name = self.typeenv.symName(term.name);
                    try writer.print("    pub fn {s}(self: *Context) !void {{\n", .{name});
                    try writer.writeAll("        _ = self;\n");
                    try writer.writeAll("        return error.Unimplemented;\n");
                    try writer.writeAll("    }\n\n");
                },
                else => {},
            }
        }

        try writer.writeAll("};\n\n");
    }

    fn emitTermFunction(self: *Self, term_id: sema.TermId, options: ZigCodegenOptions) !void {
        const writer = self.out.writer(self.allocator);
        const term = self.termenv.getTerm(term_id);
        const term_name = self.typeenv.symName(term.name);

        const sig = self.getTermSignature(term);

        if (options.debug_comments) {
            try writer.print("/// Generated lowering function for term: {s}\n", .{term_name});
        }

        // Function signature
        try writer.print("pub fn {s}{s}(\n", .{ options.fn_prefix, term_name });
        try writer.writeAll("    ctx: *Context,\n");

        // Parameters
        for (sig.params, 0..) |param_ty, i| {
            const ty_name = try self.getTypeName(param_ty);
            try writer.print("    arg{d}: {s},\n", .{ i, ty_name });
        }

        // Return type
        const ret_ty = try self.getTypeName(sig.ret_ty);
        try writer.print(") !{s} ", .{ret_ty});

        // Function body
        self.indent = 0;
        try self.beginBlock(writer);

        // Emit the decision tree as Zig code
        // For now, emit a simple fallthrough to error
        try self.emitIndent(writer);
        try writer.writeAll("_ = ctx;\n");
        for (0..sig.params.len) |i| {
            try self.emitIndent(writer);
            try writer.print("_ = arg{d};\n", .{i});
        }
        try self.emitIndent(writer);
        try writer.writeAll("return error.NoMatch;\n");

        try self.endBlock(writer);
        try writer.writeAll("\n");
    }

    /// Get the signature for a term.
    fn getTermSignature(_: *const Self, term: sema.Term) TermSignature {
        return switch (term.kind) {
            .decl => |d| .{
                .params = d.arg_tys,
                .ret_ty = d.ret_ty,
            },
            .extractor => |e| .{
                .params = e.arg_tys,
                .ret_ty = e.ret_ty,
            },
            .extern_func => |e| .{
                .params = e.arg_tys,
                .ret_ty = e.ret_ty,
            },
        };
    }

    /// Get Zig type name for a type ID.
    fn getTypeName(self: *const Self, type_id: sema.TypeId) ![]const u8 {
        const ty = self.typeenv.getType(type_id);
        return switch (ty) {
            .primitive => |p| self.typeenv.symName(p.name),
            .enum_type => |e| self.typeenv.symName(e.name),
            .builtin => |b| switch (b) {
                .bool => "bool",
                .unit => "void",
            },
        };
    }

    /// Emit a pattern match as Zig code.
    fn emitPatternMatch(
        self: *Self,
        writer: anytype,
        binding_id: trie.BindingId,
        constraint: trie.Constraint,
    ) !void {
        const binding = self.ruleset.bindings.items[binding_id.index()];

        try self.emitIndent(writer);
        try writer.writeAll("if (");

        // Emit the test based on constraint type
        switch (constraint) {
            .const_bool => |c| {
                try self.emitBinding(writer, binding);
                try writer.print(" == {s}) ", .{if (c.val) "true" else "false"});
            },
            .const_int => |c| {
                try self.emitBinding(writer, binding);
                try writer.print(" == {d}) ", .{c.val});
            },
            .const_prim => |c| {
                try self.emitBinding(writer, binding);
                const val_name = self.typeenv.symName(c.val);
                try writer.print(" == .{s}) ", .{val_name});
            },
            .variant => |v| {
                try self.emitBinding(writer, binding);
                const ty = self.typeenv.getType(v.ty);
                if (ty == .enum_type) {
                    const variant = ty.enum_type.variants[v.variant.variant_index];
                    const variant_name = self.typeenv.symName(variant.name);
                    try writer.print(" == .{s}) ", .{variant_name});
                } else {
                    try writer.writeAll("false) ");
                }
            },
            .some => {
                try self.emitBinding(writer, binding);
                try writer.writeAll(" != null) ");
            },
        }

        try self.beginBlock(writer);
    }

    /// Emit code to access a binding.
    fn emitBinding(self: *const Self, writer: anytype, binding: trie.Binding) !void {
        switch (binding) {
            .argument => |arg| {
                try writer.print("arg{d}", .{arg.index.value()});
            },
            .const_bool => |c| {
                try writer.writeAll(if (c.val) "true" else "false");
            },
            .const_int => |c| {
                try writer.print("{d}", .{c.val});
            },
            .const_prim => |c| {
                const val_name = self.typeenv.symName(c.val);
                try writer.print(".{s}", .{val_name});
            },
            .constructor => |ctor| {
                const term = self.termenv.getTerm(ctor.term);
                const name = self.typeenv.symName(term.name);
                try writer.print("{s}(ctx", .{name});
                for (ctor.parameters) |param_id| {
                    try writer.writeAll(", ");
                    const param = self.ruleset.bindings.items[param_id.index()];
                    try self.emitBinding(writer, param);
                }
                try writer.writeByte(')');
            },
            .match_variant => |mv| {
                const src_binding = self.ruleset.bindings.items[mv.source.index()];
                try self.emitBinding(writer, src_binding);
                const ty = self.typeenv.getType(mv.variant.type_id);
                if (ty == .enum_type) {
                    const variant = ty.enum_type.variants[mv.variant.variant_index];
                    if (mv.field.value() < variant.fields.len) {
                        const field = variant.fields[mv.field.value()];
                        const field_name = self.typeenv.symName(field.name);
                        try writer.print(".{s}", .{field_name});
                    }
                }
            },
            .match_some => |ms| {
                const src_binding = self.ruleset.bindings.items[ms.source.index()];
                try self.emitBinding(writer, src_binding);
                try writer.writeAll(".?");
            },
            else => {
                try writer.writeAll("@compileError(\"unsupported binding type\")");
            },
        }
    }

    /// Emit indentation.
    fn emitIndent(self: *const Self, writer: anytype) !void {
        var i: usize = 0;
        while (i < self.indent) : (i += 1) {
            try writer.writeAll("    ");
        }
    }

    /// Begin a new code block.
    fn beginBlock(self: *Self, writer: anytype) !void {
        try writer.writeAll("{\n");
        self.indent += 1;
    }

    /// End a code block.
    fn endBlock(self: *Self, writer: anytype) !void {
        self.indent -= 1;
        try self.emitIndent(writer);
        try writer.writeByte('}');
    }
};

/// Term function signature.
const TermSignature = struct {
    params: []const sema.TypeId,
    ret_ty: sema.TypeId,
};

test "ZigEmitter basic structure" {
    var typeenv = sema.TypeEnv.init(testing.allocator);
    defer typeenv.deinit();

    var termenv = sema.TermEnv.init(testing.allocator);
    defer termenv.deinit();

    // Create a simple type
    const i32_sym = try typeenv.internSym("i32");
    const i32_ty = try typeenv.addType(.{ .primitive = .{
        .id = sema.TypeId.new(0),
        .name = i32_sym,
        .pos = sema.Pos.new(0, 0),
    } });

    // Create a term
    const add_sym = try typeenv.internSym("iadd");
    const add_term = sema.Term{
        .name = add_sym,
        .id = sema.TermId.new(0),
        .kind = .{ .decl = .{
            .arg_tys = @constCast(&[_]sema.TypeId{ i32_ty, i32_ty }),
            .ret_ty = i32_ty,
            .pure = true,
        } },
        .pos = sema.Pos.new(0, 0),
    };
    const term_id = try termenv.addTerm(add_term);

    var ruleset = trie.RuleSet.init(testing.allocator);
    defer ruleset.deinit();

    var emitter = ZigEmitter.init(testing.allocator, &typeenv, &termenv, &ruleset);
    defer emitter.deinit();

    const code = try emitter.generate(term_id, .{});

    // Verify basic structure
    try testing.expect(std.mem.indexOf(u8, code, "pub fn iadd") != null);
    try testing.expect(std.mem.indexOf(u8, code, "arg0: i32") != null);
    try testing.expect(std.mem.indexOf(u8, code, "arg1: i32") != null);
    try testing.expect(std.mem.indexOf(u8, code, "ctx: *Context") != null);
}

test "ZigEmitter type name generation" {
    var typeenv = sema.TypeEnv.init(testing.allocator);
    defer typeenv.deinit();

    var termenv = sema.TermEnv.init(testing.allocator);
    defer termenv.deinit();

    // Add a primitive type
    const i32_sym = try typeenv.internSym("i32");
    const i32_ty = try typeenv.addType(.{ .primitive = .{
        .id = sema.TypeId.new(0),
        .name = i32_sym,
        .pos = sema.Pos.new(0, 0),
    } });

    var ruleset = trie.RuleSet.init(testing.allocator);
    defer ruleset.deinit();

    const emitter = ZigEmitter.init(testing.allocator, &typeenv, &termenv, &ruleset);

    // Test primitive type
    const type_name = try emitter.getTypeName(i32_ty);
    try testing.expectEqualStrings("i32", type_name);
}

test "ZigEmitter context trait generation" {
    var typeenv = sema.TypeEnv.init(testing.allocator);
    defer typeenv.deinit();

    var termenv = sema.TermEnv.init(testing.allocator);
    defer termenv.deinit();

    // Create a void return type
    const void_ty = try typeenv.addType(.{ .builtin = .unit });

    // Add an external function
    const ext_sym = try typeenv.internSym("external_fn");
    const ext_term = sema.Term{
        .name = ext_sym,
        .id = sema.TermId.new(0),
        .kind = .{ .extern_func = .{
            .arg_tys = &.{},
            .ret_ty = void_ty,
        } },
        .pos = sema.Pos.new(0, 0),
    };
    _ = try termenv.addTerm(ext_term);

    var ruleset = trie.RuleSet.init(testing.allocator);
    defer ruleset.deinit();

    var emitter = ZigEmitter.init(testing.allocator, &typeenv, &termenv, &ruleset);
    defer emitter.deinit();

    const code = try emitter.generate(sema.TermId.new(0), .{});

    // Verify context trait is generated
    try testing.expect(std.mem.indexOf(u8, code, "pub const Context") != null);
    try testing.expect(std.mem.indexOf(u8, code, "allocator: Allocator") != null);
}
