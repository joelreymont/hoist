const std = @import("std");
const testing = std.testing;
const Allocator = std.mem.Allocator;

const sema = @import("sema.zig");

/// Code generation options.
pub const CodegenOptions = struct {
    /// Prefix for generated functions.
    prefix: []const u8 = "",
    /// Include debug comments.
    debug_comments: bool = false,
};

/// Zig code generator for ISLE rules.
pub const Codegen = struct {
    /// Type environment.
    typeenv: *const sema.TypeEnv,
    /// Term environment.
    termenv: *const sema.TermEnv,
    /// Compiled rules.
    rules: []const sema.Rule,
    /// Output buffer.
    output: std.ArrayList(u8),
    /// Allocator.
    allocator: Allocator,

    const Self = @This();

    pub fn init(
        allocator: Allocator,
        typeenv: *const sema.TypeEnv,
        termenv: *const sema.TermEnv,
        rules: []const sema.Rule,
    ) Self {
        return .{
            .typeenv = typeenv,
            .termenv = termenv,
            .rules = rules,
            .output = std.ArrayList(u8){},
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *Self) void {
        self.output.deinit(self.allocator);
    }

    /// Generate Zig code from the compiled rules.
    pub fn generate(self: *Self, options: CodegenOptions) ![]const u8 {
        try self.emitPreamble();
        try self.emitRuleFunctions(options);
        return self.output.items;
    }

    fn emitPreamble(self: *Self) !void {
        const writer = self.output.writer(self.allocator);
        try writer.writeAll(
            \\// Auto-generated by ISLE compiler
            \\const std = @import("std");
            \\
            \\
        );
    }

    fn emitRuleFunctions(self: *Self, options: CodegenOptions) !void {
        const writer = self.output.writer(self.allocator);

        // Group rules by term
        var term_rules = std.AutoHashMap(sema.TermId, std.ArrayList(usize)).init(self.allocator);
        defer {
            var it = term_rules.valueIterator();
            while (it.next()) |list| {
                list.deinit(self.allocator);
            }
            term_rules.deinit();
        }

        for (self.rules, 0..) |rule, i| {
            const term_id = switch (rule.pattern) {
                .term => |t| t.term_id,
                else => continue,
            };

            const entry = try term_rules.getOrPut(term_id);
            if (!entry.found_existing) {
                entry.value_ptr.* = std.ArrayList(usize){};
            }
            try entry.value_ptr.append(self.allocator, i);
        }

        // Generate a function for each term
        var it = term_rules.iterator();
        while (it.next()) |entry| {
            const term_id = entry.key_ptr.*;
            const rule_indices = entry.value_ptr.items;

            const term = self.termenv.getTerm(term_id);
            const term_name = self.typeenv.symName(term.name);

            // Function signature
            try writer.print(
                \\/// Generated lowering for {s}
                \\pub fn {s}{s}(
            , .{ term_name, options.prefix, term_name });

            // Generate parameters based on term signature
            const arg_tys = switch (term.kind) {
                .decl => |d| d.arg_tys,
                .extractor => |e| e.arg_tys,
                .extern_func => |e| e.arg_tys,
            };

            for (arg_tys, 0..) |arg_ty, idx| {
                const ty = self.typeenv.types.items[arg_ty.index()];
                const ty_name = switch (ty) {
                    .primitive => |p| self.typeenv.symName(p.name),
                    .enum_type => |e| self.typeenv.symName(e.name),
                    else => "Value",
                };
                try writer.print("arg{d}: {s}", .{ idx, ty_name });
                if (idx < arg_tys.len - 1) {
                    try writer.writeAll(", ");
                }
            }

            const ret_ty = switch (term.kind) {
                .decl => |d| d.ret_ty,
                .extractor => |e| e.ret_ty,
                .extern_func => |e| e.ret_ty,
            };
            const ret_ty_obj = self.typeenv.types.items[ret_ty.index()];
            const ret_ty_name = switch (ret_ty_obj) {
                .primitive => |p| self.typeenv.symName(p.name),
                .enum_type => |e| self.typeenv.symName(e.name),
                else => "Value",
            };

            try writer.print(") {s} {{\n", .{ret_ty_name});

            // Emit rules for this term
            for (rule_indices, 0..) |rule_idx, i| {
                const rule = self.rules[rule_idx];

                if (options.debug_comments) {
                    try writer.print("    // Rule {d}\n", .{rule_idx});
                }

                // For now, just emit a simple return statement
                // Full implementation would generate pattern matching
                if (i == 0) {
                    try self.emitRuleBody(rule, 4);
                }
            }

            // Default return for unmatched patterns
            try writer.writeAll("    return error.NoMatch;\n");
            try writer.writeAll("}\n\n");
        }
    }

    fn emitRuleBody(self: *Self, rule: sema.Rule, indent: usize) !void {
        const writer = self.output.writer(self.allocator);

        // Emit pattern matching
        try self.emitIndent(indent);
        try writer.writeAll("// Pattern: ");
        try self.emitPattern(rule.pattern);
        try writer.writeByte('\n');

        // Emit expression evaluation
        try self.emitIndent(indent);
        try writer.writeAll("return ");
        try self.emitExpr(rule.expr);
        try writer.writeAll(";\n");
    }

    fn emitPattern(self: *Self, pattern: sema.Pattern) !void {
        const writer = self.output.writer(self.allocator);

        switch (pattern) {
            .var_pat => |v| {
                const name = self.typeenv.symName(v.name);
                try writer.writeAll(name);
            },
            .term => |t| {
                const term = self.termenv.getTerm(t.term_id);
                const name = self.typeenv.symName(term.name);
                try writer.print("({s}", .{name});
                for (t.args) |arg| {
                    try writer.writeByte(' ');
                    try self.emitPattern(arg);
                }
                try writer.writeByte(')');
            },
            else => {
                try writer.writeAll("<pattern>");
            },
        }
    }

    fn emitExpr(self: *Self, expr: sema.Expr) !void {
        const writer = self.output.writer(self.allocator);

        switch (expr) {
            .var_expr => |v| {
                const name = self.typeenv.symName(v.name);
                try writer.writeAll(name);
            },
            .term => |t| {
                const term = self.termenv.getTerm(t.term_id);
                const name = self.typeenv.symName(term.name);
                try writer.print("{s}(", .{name});
                for (t.args, 0..) |arg, i| {
                    if (i > 0) try writer.writeAll(", ");
                    try self.emitExpr(arg);
                }
                try writer.writeByte(')');
            },
            else => {
                try writer.writeAll("error.Unimplemented");
            },
        }
    }

    fn emitIndent(self: *Self, count: usize) !void {
        const writer = self.output.writer(self.allocator);
        var i: usize = 0;
        while (i < count) : (i += 1) {
            try writer.writeByte(' ');
        }
    }
};

test "Codegen basic structure" {
    var typeenv = sema.TypeEnv.init(testing.allocator);
    defer typeenv.deinit();

    var termenv = sema.TermEnv.init(testing.allocator);
    defer termenv.deinit();

    // Create a simple type
    const i32_sym = try typeenv.internSym("i32");
    const i32_ty = try typeenv.addType(.{ .primitive = .{
        .id = sema.TypeId.new(0),
        .name = i32_sym,
        .pos = sema.Pos.new(0, 0),
    } });

    // Create a term: iadd(i32, i32) -> i32
    const iadd_sym = try typeenv.internSym("iadd");
    const iadd_term = sema.Term{
        .name = iadd_sym,
        .id = sema.TermId.new(0),
        .kind = .{ .decl = .{
            .arg_tys = @constCast(&[_]sema.TypeId{ i32_ty, i32_ty }),
            .ret_ty = i32_ty,
            .pure = true,
        } },
        .pos = sema.Pos.new(0, 0),
    };
    _ = try termenv.addTerm(iadd_term);

    // Create a simple rule: (iadd x y) => (iadd y x)
    const x_sym = try typeenv.internSym("x");
    const y_sym = try typeenv.internSym("y");

    const pattern = sema.Pattern{ .term = .{
        .term_id = sema.TermId.new(0),
        .args = @constCast(&[_]sema.Pattern{
            .{ .var_pat = .{
                .var_id = 0,
                .name = x_sym,
                .ty = i32_ty,
                .pos = sema.Pos.new(0, 0),
            } },
            .{ .var_pat = .{
                .var_id = 1,
                .name = y_sym,
                .ty = i32_ty,
                .pos = sema.Pos.new(0, 0),
            } },
        }),
        .ty = i32_ty,
        .pos = sema.Pos.new(0, 0),
    } };

    const expr = sema.Expr{ .term = .{
        .term_id = sema.TermId.new(0),
        .args = @constCast(&[_]sema.Expr{
            .{ .var_expr = .{
                .var_id = 1,
                .name = y_sym,
                .ty = i32_ty,
                .pos = sema.Pos.new(0, 0),
            } },
            .{ .var_expr = .{
                .var_id = 0,
                .name = x_sym,
                .ty = i32_ty,
                .pos = sema.Pos.new(0, 0),
            } },
        }),
        .ty = i32_ty,
        .pos = sema.Pos.new(0, 0),
    } };

    const rule = sema.Rule{
        .pattern = pattern,
        .iflets = @constCast(&[0]sema.IfLet{}),
        .expr = expr,
        .prio = 0,
        .pos = sema.Pos.new(0, 0),
    };

    const rules = [_]sema.Rule{rule};

    var codegen = Codegen.init(testing.allocator, &typeenv, &termenv, &rules);
    defer codegen.deinit();

    const code = try codegen.generate(.{});

    // Check that code contains basic structure
    try testing.expect(std.mem.indexOf(u8, code, "pub fn iadd") != null);
    try testing.expect(std.mem.indexOf(u8, code, "arg0: i32") != null);
    try testing.expect(std.mem.indexOf(u8, code, "arg1: i32") != null);
}
